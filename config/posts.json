{
  "posts": [
    {
      "content": "\n原先的 WordPress 博客使用的MySQL 数据，最近打算迁移到 PostgreSQL 上面。迁移的目的主要是想体验PostgreSQL ，第二个是 PostgreSQL 在dockers上运行是占用的内存较少，对于内存不够的机子很友好，\n\n下面是我Docker 上运行的两个数据库内存占用的情况：\n\n![](https://werls.top/post-images/1686468592068.png)\n\n可以看出，MySQL 占用的内存还很多的。\n\n\n\n\n\n\n\n",
      "data": {
        "title": "MySQL 数据库迁移到PostgreSQL 上",
        "date": "2023-06-11 15:10:59",
        "tags": [],
        "published": true,
        "hideInList": true,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "mysql-shu-ju-ku-qian-yi-dao-postgresql-shang"
    },
    {
      "content": "\n\n\n我之前的博客是使用WordPress搭建在一个只有512m 内存服务器上，运行非常卡顿、并且很久没有给博客进行更新了，\n\n最近打算把他迁移到新的服务器上，同时更改域名，让原来域名指向本站点。\n\n\n",
      "data": {
        "title": "给博客换个家",
        "date": "2023-06-10 19:15:55",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "gei-bo-ke-huan-ge-jia"
    },
    {
      "content": "\r\n## JWT\r\nJWT(JSON Web Token)是当前最流行的跨域身份验证解决方案。\r\n它的工作原理是:\r\n1. 客户端用用户名和密码请求服务器\r\n2. 服务器验证通过后,生成一个JWT,返回给客户端\r\n3. 客户端将JWT存储起来,并在每次请求时附带在Authorization头中\r\n4. 服务器验证JWT的有效性,如果通过就允许请求\r\n\r\n\r\nJWT的结构很简单,就是三段信息用.连接成一个字符串:\r\n - 头部(header):包含算法和token类型\r\n - 负载(payload):包含声明(claim),像用户名、过期时间等\r\n - 签名(signature):由header和payload加上secret使用指定的算法(如HMAC SHA256)计算得出\r\n  \r\n  例如:\r\n\r\n\r\n\r\n```\r\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ\r\n```\r\n\r\n\r\n\r\n- 头部: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`\r\n\r\n- 负载: `eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9`\r\n\r\n- 签名:`TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ`\r\n  \r\n  \r\n\r\n使用JWT的优点:\r\n\r\n1. 跨域身份验证:JWT可以在不同的域中传递,使用者无需再在每个域中维护一份用户信息。\r\n\r\n2. 易于使用:JWT可以通过URL,POST参数或者在HTTP header发送。\r\n\r\n3. 无状态:JWT是自包含的,无需在服务器端保存会话信息。\r\n\r\n4. 轻量: JWT通常使用URL safe字符集,这使其可以很轻易地通过URL,POST参数或HTTP header传输,而不会被破坏。\r\n\r\n所以,JWT适用于跨域身份验证场景,并能简化OAUTH2.0的使用。\r\n",
      "data": {
        "title": "为Spring Boot 3 +  Spring-Security 配置JWT",
        "date": "2023-06-10 18:47:21",
        "tags": [],
        "published": true,
        "hideInList": true,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "wei-spring-boot-3-spring-security-pei-zhi-jwt"
    },
    {
      "content": "2379. 得到 K 个黑块的最少涂色次数\r\n\r\n\r\n给你一个长度为 n下标从 0开始的字符串blocks，blocks[i]要么是'W'要么是'B'，表示第i块的颜色。字符'W' 和'B'分别表示白色和黑色。\r\n\r\n给你一个整数k，表示想要连续黑色块的数目。 每一次操作中，你可以选择一个白色块将它 涂成黑色块。 请你返回至少出现 一次连续 k个黑色块的 最少操作次数。\r\n\r\n<!-- more -->\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n\r\n```text\r\n\r\n输入：blocks = \"WBBWWBBWBW\", k = 7\r\n输出：3\r\n解释：\r\n一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。\r\n得到 blocks = \"BBBBBBBWBW\" 。\r\n可以证明无法用少于 3 次操作得到 7 个连续的黑块。\r\n所以我们返回 3 。\r\n输入：blocks = \"WBWBBBW\", k = 2\r\n输出：0\r\n解释：\r\n不需要任何操作，因为已经有 2 个连续的黑块。\r\n所以我们返回 0 。\r\n\r\n```\r\n\r\n#### 提示\r\n\r\n* n == blocks.length\r\n*   1 <= n <= 100\r\n*   blocks[i] 要么是 'W' ，要么是 'B' 。\r\n*  1 <= k <= n\r\n\r\n\r\n```java\r\n\r\n/**\r\n\r\n *\r\n * @author Li JiaWei\r\n * @version TODO\r\n * @date 2023/3/9\r\n * @since on\r\n */\r\npublic class MinimumRecolors_2379 {\r\n  \r\n  public static int minimumRecolors(String blocks, int k) {\r\n    // 这个是一个滑动窗口问题，\r\n    // 返回一个k 少操作次数的\r\n    int a = 0, b = 0, c = 0;\r\n    while (a < k) {\r\n      // 前几个次数\r\n      c += blocks.charAt(a) == 'W' ? 1 : 0;\r\n      a++;\r\n    }\r\n    int as = c;\r\n    while (a < blocks.length()) {\r\n      // 右\r\n      c += blocks.charAt(a) == 'W' ? 1 : 0;\r\n      //左\r\n      c -= blocks.charAt(b) == 'W' ? 1 : 0;\r\n      b++;\r\n      a++;\r\n      as = Math.min(as, c);\r\n    }\r\n    return as;\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n    var a = \"WBBWWBBWBW\";\r\n\r\n    System.out.println(minimumRecolors(a, 7));\r\n  }\r\n}\r\n\r\n```\r\n",
      "data": {
        "title": "得到 K 个黑块的最少涂色次数",
        "date": "2023-03-10 18:27:41",
        "tags": [
          "leetcode"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "2379. 得到 K 个黑块的最少涂色次数\r\n\r\n\r\n给你一个长度为 n下标从 0开始的字符串blocks，blocks[i]要么是'W'要么是'B'，表示第i块的颜色。字符'W' 和'B'分别表示白色和黑色。\r\n\r\n给你一个整数k，表示想要连续黑色块的数目。 每一次操作中，你可以选择一个白色块将它 涂成黑色块。 请你返回至少出现 一次连续 k个黑色块的 最少操作次数。\r",
      "fileName": "de-dao-k-ge-hei-kuai-de-zui-shao-tu-se-ci-shu"
    },
    {
      "content": "在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？\r\n\r\n<!-- more -->\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n*  示例 1:\r\n\r\n```text\r\n输入:\r\n[\r\n[1,3,1],\r\n[1,5,1],\r\n[4,2,1]\r\n]\r\n输出: 12\r\n解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物\r\n\r\n```\r\n\r\n* 提示\r\n  * `0 < grid.length <= 200`\r\n  * `0 < grid[0].length <= 200`\r\n\r\n\r\n\r\n这个是动态规划问题。 我们可以把问题转化为 获取下或者右的一个单位的的最大值。\r\n\r\n```java\r\n\r\n\r\n/**\r\n * 剑指 Offer 47. 礼物的最大价值 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于\r\n * 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？\r\n * <p>\r\n * 来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof\r\n * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n *\r\n * @author Li JiaWei\r\n * @version TODO\r\n * @date 2023/3/8\r\n * @since on\r\n */\r\npublic class GiftMaximum_2704 {\r\n\r\n  /**\r\n   * 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于\r\n   * 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？\r\n   * <p>\r\n   * 来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof\r\n   * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 12 解释: 路径 1→3→5→2→1\r\n   * 可以拿到最多价值的礼物 提示：\r\n   * <p>\r\n   * 0 < grid.length <= 200 0 < grid[0].length <= 200\r\n   *\r\n   * @param grid\r\n   * @return\r\n   */\r\n  public static int maxValue(int[][] grid) {\r\n    //  这是一个简单的 动态规划问题，\r\n    // 实际上我要做的是 上或者下 去一个最大值。\r\n    // f(x,y) = max( x,y+1) (x+1,y)+ (x-1,y-1) 前一个位置的值。\r\n    int l = grid.length, r = grid[0].length;\r\n    int[][] w = new int[l][r];\r\n    for (int i = 0; i < l; i++) {\r\n      for (int j = 0; j < r; j++) {\r\n        if (i > 0) {\r\n          w[i][j] = Math.max(w[i][j], w[i - 1][j]);\r\n        }\r\n        if (j > 0) {\r\n          w[i][j] = Math.max(w[i][j], w[i][j - 1]);\r\n        }\r\n        w[i][j] += grid[i][j];\r\n      }\r\n    }\r\n    System.out.println(w[l - 1][r - 1]);\r\n    // 因为只需要前后两行居矩阵 ，可以这样\r\n    int[][] w1 = new int[2][r];\r\n    for (int i = 0; i < l; i++) {\r\n      for (int j = 0; j < r; j++) {\r\n        int pos = i % 2;\r\n        if (i > 0) {\r\n          w1[pos][j] = Math.max(w1[pos][j], w1[1 - pos][j]);\r\n        }\r\n        if (j > 0) {\r\n          w1[pos][j] = Math.max(w1[pos][j], w1[pos][j - 1]);\r\n        }\r\n        w1[pos][j] += grid[i][j];\r\n      }\r\n    }\r\n    System.out.println(w1[(l - 1) % 2][r - 1]);\r\n\r\n    int[] dp = new int[r + 1];\r\n    for (int i = 1; i <= l; i++) {\r\n      for (int j = 1; j <= r; j++) {\r\n        dp[i] = Math.max(dp[i], dp[j - 1]) + grid[i - 1][j - 1];\r\n//        System.out.println( dp[i]);\r\n      }\r\n    }\r\n\r\n    return dp[r];\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n    int[][] gif = {\r\n        {1, 3, 1},\r\n        {1, 5, 1},\r\n        {4, 2, 1}\r\n    };\r\n    var max = maxValue(gif);\r\n    System.out.println(max);\r\n  }\r\n}\r\n\r\n```",
      "data": {
        "title": "剑指 Offer 47. 礼物的最大价值",
        "date": "2023-03-09 18:10:38",
        "tags": [
          "leetcode"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？\r",
      "fileName": "jian-zhi-offer-47-li-wu-de-zui-da-jie-zhi"
    },
    {
      "content": "\r\n```java\r\npublic class TwoSum {\r\n     public static int[] twoSum(int[] numbers, int target) {\r\n        int high = numbers.length - 1, low = 0;\r\n        while (low < high) {\r\n            int sum = numbers[low] + numbers[high];\r\n            if (sum == target) {\r\n                return new int[] { low + 1, high + 1 };\r\n            } else if (sum > target) {\r\n                --high;\r\n            } else {\r\n                ++low;\r\n            }\r\n        }\r\n        return new int[] { -1, -1 };\r\n    }\r\n\r\n    public static int[] twoSum1(int[] numbers, int target) {\r\n        for (int i = 0; i < numbers.length; ++i) {\r\n            int low = i + 1, high = numbers.length - 1;\r\n            while (low < high) {\r\n                int mid = (high - low) / 2 + low;\r\n                if (target == numbers[mid] + numbers[i]) {\r\n                    return new int[] { i + 1, mid + 1 };\r\n                } else if (target > numbers[mid] + numbers[i]) {\r\n                    low = mid + 1;\r\n                } else {\r\n                    high = mid - 1;\r\n                }\r\n            }\r\n\r\n        }\r\n        return new int[] { -1, -1 };\r\n    }\r\n}\r\n```",
      "data": {
        "title": "两数之和",
        "date": "2023-03-07 21:12:31",
        "tags": [
          "leetcode"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "liang-shu-zhi-he"
    },
    {
      "content": "给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。\r\n\r\n\r\n<!-- more -->\r\n这个问题和 七桥问题 相同，看能不能一次性的走完机场。\r\n\r\n```java\r\npublic List<String> findItinerary(List<List<String>> tickets) {\r\n        List<String> res = new ArrayList<>();\r\n        Map<String, PriorityQueue<String>> map = new HashMap<>(16);\r\n//        邻接表\r\n        for (List<String> list :\r\n                tickets) {\r\n            String dep = list.get(0), destination = list.get(1);\r\n            if (!map.containsKey(dep)) {\r\n                map.put(dep, new PriorityQueue<>());\r\n            }\r\n            map.get(dep).offer(destination);\r\n        }\r\n        dfs(map, res, \"JFK\");\r\n    // 逆序反转\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n\r\n    private void dfs(Map<String, PriorityQueue<String>> map, List<String> res, String dep) {\r\n        while (map.containsKey(dep) && map.get(dep).size() > 0) {\r\n            String tem = map.get(dep).poll();\r\n            dfs(map, res, tem);\r\n        }\r\n        res.add(dep);\r\n    }\r\n```",
      "data": {
        "title": "重新安排行程",
        "date": "2023-03-07 20:57:29",
        "tags": [
          "leetcode"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。\r",
      "fileName": "chong-xin-an-pai-xing-cheng"
    },
    {
      "content": "> 欢迎来到我的小站呀，很高兴遇见你！🤝\n\n\n\n## 📬 联系我呀\n\n",
      "data": {
        "title": "关于",
        "date": "2019-01-25 19:09:48",
        "tags": [],
        "published": true,
        "hideInList": true,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "about"
    }
  ],
  "tags": [
    {
      "index": -1,
      "name": "leetcode",
      "slug": "BKkOx1GzE",
      "used": true
    },
    {
      "index": -1,
      "name": "GitLab",
      "slug": "-Bapd1K0i",
      "used": false
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "归档",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "标签",
      "openType": "Internal"
    },
    {
      "link": "/post/about",
      "name": "关于",
      "openType": "Internal"
    }
  ]
}